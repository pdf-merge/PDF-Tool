name: "Intelligent Book Downloader (PaddleOCR)"
on:
  workflow_dispatch:
    inputs:
      BOOK_ID:
        description: "BOOK_ID to download"
        required: true
        default: "1"
      THREADS:
        description: "S·ªë lu·ªìng t·∫£i ·∫£nh ƒë·ªìng th·ªùi (max threads)"
        required: true
        default: "512"
      PERFORM_OCR:
        description: "Th·ª±c hi·ªán OCR (nh·∫≠n d·∫°ng ch·ªØ) cho file PDF?"
        required: true
        default: "yes"
        type: choice
        options:
          - "yes"
          - "no"
env:
  TZ: Asia/Ho_Chi_Minh

jobs:
  download:
    runs-on: ubuntu-22.04
    timeout-minutes: 720 # PaddleOCR ch·∫°y l√¢u n√™n gi·ªØ timeout cao
    env:
      BOOK_ID: ${{ github.event.inputs.BOOK_ID }}
      THREADS: ${{ github.event.inputs.THREADS }}
      PERFORM_OCR: ${{ github.event.inputs.PERFORM_OCR }}
      PYTHONPATH: ${{ github.workspace }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          repository: 'proplayer1131/sachyhocpdf_downloader-main'
          token: ${{ secrets.ACTION_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10" # Paddle ·ªïn ƒë·ªãnh nh·∫•t tr√™n 3.10

      - name: Select Account Sequentially
        id: select_account
        env:
          ACCOUNTS_SECRET: ${{ secrets.BHLNK_ACCOUNTS }}
          RUN_NUMBER: ${{ github.run_number }}
        run: |
          ACCOUNTS_LIST=$(echo "${ACCOUNTS_SECRET}" | sed '/^\s*$/d')
          TOTAL_ACCOUNTS=$(echo "${ACCOUNTS_LIST}" | wc -l)
          ACCOUNT_INDEX=$(( (RUN_NUMBER - 1) % TOTAL_ACCOUNTS ))
          LINE_NUM=$((ACCOUNT_INDEX + 1))
          ACCOUNT_LINE=$(echo "${ACCOUNTS_LIST}" | awk "NR==${LINE_NUM}")
          BHLNK_EMAIL_VALUE=$(echo "$ACCOUNT_LINE" | cut -d: -f1)
          BHLNK_PASSWORD_VALUE=$(echo "$ACCOUNT_LINE" | cut -d: -f2-)
          echo "::add-mask::$BHLNK_EMAIL_VALUE"
          echo "::add-mask::$BHLNK_PASSWORD_VALUE"
          echo "BHLNK_EMAIL=${BHLNK_EMAIL_VALUE}" >> $GITHUB_ENV
          echo "BHLNK_PASSWORD=${BHLNK_PASSWORD_VALUE}" >> $GITHUB_ENV

      - name: Install Base Dependencies
        run: |
          sudo apt-get update
          # C√†i th√™m libgl1 cho OpenCV/Paddle
          sudo apt-get install -y \
            git jq exiftool libgl1 \
            libopenjp2-7 libffi-dev libssl-dev
          
          python -m pip install -U pip
          pip install requests Pillow psutil
          if [ -f requirements.txt ]; then
            grep -v -E 'tkinter|pywin32|win32mica|upx|customtkinter|futures|tqdm' requirements.txt > requirements_linux.txt
            pip install -r requirements_linux.txt
          fi

      - name: Install PaddleOCR Dependencies (Conditional)
        if: env.PERFORM_OCR == 'yes'
        run: |
          echo "Installing PaddleOCR and PDF tools..."
          # C√†i ƒë·∫∑t PaddlePaddle (CPU), PaddleOCR v√† PyMuPDF ƒë·ªÉ x·ª≠ l√Ω PDF
          pip install paddlepaddle paddleocr pymupdf
          echo "PaddleOCR dependencies installed."

      - name: Configure Rclone
        env:
          RCLONE_CONF_CONTENTS: ${{ secrets.RCLONE_CONF }}
        run: |
          curl -fsSL https://rclone.org/install.sh | sudo bash
          mkdir -p ~/.config/rclone
          printf "%s" "$RCLONE_CONF_CONTENTS" > ~/.config/rclone/rclone.conf

      - name: Set Main Upload Destination (for exist-check)
        id: set_destination
        run: |
          echo "RCLONE_DEST_PATH=1drive:/LSC_Books" >> $GITHUB_ENV

      - name: Run Intelligent Download Script
        id: download_script
        run: python -u scripts/download_one.py

      - name: Read Download Status
        id: status_reader
        if: always()
        run: |
          if [ -f "download_status.txt" ]; then
            STATUS=$(cat download_status.txt)
            echo "DOWNLOAD_STATUS=$STATUS" >> $GITHUB_OUTPUT
          else
            echo "DOWNLOAD_STATUS=SCRIPT_ERROR" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Sanitize Folder Name
        id: sanitize
        if: hashFiles('folder_name.txt') != ''
        run: |
          ORIGINAL_NAME=$(cat folder_name.txt)
          SANITIZED_NAME=$(echo "$ORIGINAL_NAME" | sed 's#[*:<>?\/\\|]#_#g')
          if [ "$ORIGINAL_NAME" != "$SANITIZED_NAME" ]; then
            mv -- "$ORIGINAL_NAME" "$SANITIZED_NAME"
          fi
          echo "sanitized_name=$SANITIZED_NAME" >> $GITHUB_OUTPUT

      - name: 'Force PDF Metadata (Pre-OCR Pass)'
        id: metadata_pass_1
        if: steps.status_reader.outputs.DOWNLOAD_STATUS != 'EXISTS' && steps.status_reader.outputs.DOWNLOAD_STATUS != 'SCRIPT_ERROR' && steps.status_reader.outputs.DOWNLOAD_STATUS != 'NOT_FOUND' && steps.sanitize.outputs.sanitized_name != ''
        run: |
          FOLDER_NAME="${{ steps.sanitize.outputs.sanitized_name }}"
          echo "Entering directory to apply metadata (Pass 1): $FOLDER_NAME"
          cd "$FOLDER_NAME"
          find . -name "*.pdf" -print0 | while IFS= read -r -d '' pdf_file; do
            exiftool -Title="LSC" -Author="LSC" -Subject="LSC" -Creator="LSC" -Producer="LSC" -overwrite_original "$pdf_file"
          done
          cd ..

      - name: 'Upload Book Folder (No OCR)'
        id: upload_no_ocr
        if: steps.metadata_pass_1.conclusion == 'success'
        env:
          RCLONE_DEST_PATH: "1drive:/LSC_Books/No_OCR"
        run: |
          FOLDER_NAME="${{ steps.sanitize.outputs.sanitized_name }}"
          TARGET="${{ env.RCLONE_DEST_PATH }}/${FOLDER_NAME}"
          
          echo "Uploading $FOLDER_NAME to $TARGET (No OCR)"
          rclone copy "${FOLDER_NAME}" "${TARGET}" --transfers=8 --checkers=16 --progress
          
          LINK=$(rclone link "$TARGET")
          echo "::add-mask::$LINK"
          echo "RCLONE_LINK_NO_OCR=$LINK" >> $GITHUB_ENV
        shell: bash

      - name: Create PaddleOCR Script
        if: env.PERFORM_OCR == 'yes'
        run: |
          cat <<EOF > paddle_ocr_process.py
          import os
          import fitz  # PyMuPDF
          from paddleocr import PaddleOCR
          import sys

          # Kh·ªüi t·∫°o PaddleOCR (Ti·∫øng Vi·ªát)
          # use_angle_cls=True gi√∫p xoay ch·ªØ n·∫øu b·ªã nghi√™ng
          ocr = PaddleOCR(use_angle_cls=True, lang='vi', show_log=False)

          def process_folder(folder_path):
              for root, dirs, files in os.walk(folder_path):
                  for file in files:
                      if file.lower().endswith(".pdf"):
                          full_path = os.path.join(root, file)
                          print(f"Processing OCR for: {full_path}")
                          try:
                              ocr_pdf(full_path)
                              print(f"Successfully processed: {full_path}")
                          except Exception as e:
                              print(f"Error processing {full_path}: {e}")

          def ocr_pdf(input_path):
              doc = fitz.open(input_path)
              temp_output = input_path + ".temp.pdf"
              
              # Duy·ªát t·ª´ng trang
              for page_num, page in enumerate(doc):
                  print(f"  - Page {page_num + 1}/{len(doc)}")
                  
                  # Chuy·ªÉn trang th√†nh ·∫£nh (zoom=2 ƒë·ªÉ tƒÉng ƒë·ªô n√©t cho OCR)
                  mat = fitz.Matrix(2, 2)
                  pix = page.get_pixmap(matrix=mat)
                  img_data = pix.tobytes("png")
                  
                  # Ch·∫°y PaddleOCR
                  result = ocr.ocr(img_data, cls=True)
                  
                  # N·∫øu kh√¥ng c√≥ ch·ªØ, b·ªè qua
                  if result is None or result[0] is None:
                      continue
                      
                  # result c·∫•u tr√∫c: [[[[x1,y1],[x2,y2]...], ("text", conf)], ...]
                  for line in result[0]:
                      box = line[0]
                      text = line[1][0]
                      conf = line[1][1]
                      
                      # B·ªè qua n·∫øu ƒë·ªô tin c·∫≠y qu√° th·∫•p
                      if conf < 0.5:
                          continue
                          
                      # L·∫•y t·ªça ƒë·ªô bbox (chuy·ªÉn t·ª´ zoom 2x v·ªÅ 1x)
                      # Paddle tr·∫£ v·ªÅ: Top-Left, Top-Right, Bottom-Right, Bottom-Left
                      x0 = min([p[0] for p in box]) / 2
                      y0 = min([p[1] for p in box]) / 2
                      x1 = max([p[0] for p in box]) / 2
                      y1 = max([p[1] for p in box]) / 2
                      
                      rect = fitz.Rect(x0, y0, x1, y1)
                      
                      # Ch√®n text ·∫©n (render_mode=3: invisible)
                      try:
                          page.insert_text(rect.tl, text, fontsize=10, render_mode=3)
                      except:
                          pass
                          
              doc.save(temp_output)
              doc.close()
              
              # Thay th·∫ø file g·ªëc
              os.replace(temp_output, input_path)

          if __name__ == "__main__":
              target_folder = sys.argv[1]
              process_folder(target_folder)
          EOF

      - name: Run PaddleOCR (Custom Python)
        id: ocr
        if: steps.status_reader.outputs.DOWNLOAD_STATUS != 'EXISTS' && steps.status_reader.outputs.DOWNLOAD_STATUS != 'SCRIPT_ERROR' && steps.status_reader.outputs.DOWNLOAD_STATUS != 'NOT_FOUND' && steps.sanitize.outputs.sanitized_name != '' && env.PERFORM_OCR == 'yes'
        run: |
          FOLDER_NAME="${{ steps.sanitize.outputs.sanitized_name }}"
          echo "Entering directory for PaddleOCR: $FOLDER_NAME"
          
          # Ch·∫°y script Python v·ª´a t·∫°o
          python paddle_ocr_process.py "$FOLDER_NAME"
          
          echo "OCR processing complete."

      - name: 'Force PDF Metadata (Post-OCR Pass)'
        id: metadata_pass_2
        if: steps.ocr.conclusion == 'success' && env.PERFORM_OCR == 'yes'
        run: |
          FOLDER_NAME="${{ steps.sanitize.outputs.sanitized_name }}"
          cd "$FOLDER_NAME"
          find . -name "*.pdf" -print0 | while IFS= read -r -d '' pdf_file; do
            exiftool -Title="LSC" -Author="LSC" -Subject="LSC" -Creator="LSC" -Producer="LSC" -overwrite_original "$pdf_file"
          done
          cd ..

      - name: 'Upload Book Folder (OCR)'
        id: upload_ocr
        if: steps.metadata_pass_2.conclusion == 'success' && env.PERFORM_OCR == 'yes'
        env:
          RCLONE_DEST_PATH: "1drive:/LSC_Books"
        run: |
          FOLDER_NAME="${{ steps.sanitize.outputs.sanitized_name }}"
          TARGET="${{ env.RCLONE_DEST_PATH }}/${FOLDER_NAME}"
          
          echo "Uploading $FOLDER_NAME to $TARGET (OCR)"
          rclone copy "${FOLDER_NAME}" "${TARGET}" --transfers=8 --checkers=16 --progress
          
          LINK=$(rclone link "$TARGET")
          if [ -z "$LINK" ]; then LINK="Kh√¥ng th·ªÉ t·∫°o link"; fi
          echo "::add-mask::$LINK"
          echo "RCLONE_LINK_OCR=$LINK" >> $GITHUB_ENV
        shell: bash

      - name: Finalize Telegram Message
        if: always() && hashFiles('telegram_message.txt') != ''
        run: |
          LINK_NO_OCR="${{ env.RCLONE_LINK_NO_OCR }}"
          LINK_OCR="${{ env.RCLONE_LINK_OCR }}"
          PERFORMED_OCR="${{ env.PERFORM_OCR }}"
          
          if [ -n "$LINK_NO_OCR" ]; then
            sed -i "s|\[ƒêang x·ª≠ l√Ω...\]|\[Nh·∫•n v√†o ƒë√¢y\]($LINK_NO_OCR)|g" telegram_message.txt
            sed -i "s|üîó Link T·∫£i:|üîó Link (No-OCR):|g" telegram_message.txt
          else
            sed -i "s|\[ƒêang x·ª≠ l√Ω...\]|\[Upload th·∫•t b·∫°i\]|g" telegram_message.txt
            sed -i "s|üîó Link T·∫£i:|üîó Link (No-OCR):|g" telegram_message.txt
          fi
          
          if [ "$PERFORMED_OCR" == "yes" ]; then
            if [ -n "$LINK_OCR" ]; then
              echo "üîó Link (OCR - Paddle): [Nh·∫•n v√†o ƒë√¢y]($LINK_OCR)" >> telegram_message.txt
            else
              echo "üîó Link (OCR - Paddle): [Upload th·∫•t b·∫°i]" >> telegram_message.txt
            fi
          fi

      - name: Upload Result Message
        if: always() && hashFiles('telegram_message.txt') != ''
        uses: actions/upload-artifact@v4
        with:
          name: result-message-${{ github.run_id }}
          path: telegram_message.txt
          retention-days: 1
