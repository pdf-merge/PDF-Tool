name: "Intelligent Book Downloader (PaddleOCR Final)"
on:
  workflow_dispatch:
    inputs:
      BOOK_ID: {required: true, default: "1"}
      THREADS: {required: true, default: "512"}
      PERFORM_OCR: {required: true, default: "yes", type: choice, options: ["yes", "no"]}
env: {TZ: Asia/Ho_Chi_Minh}
jobs:
  download:
    runs-on: ubuntu-22.04
    timeout-minutes: 720
    env:
      BOOK_ID: ${{ github.event.inputs.BOOK_ID }}
      THREADS: ${{ github.event.inputs.THREADS }}
      PERFORM_OCR: ${{ github.event.inputs.PERFORM_OCR }}
      PYTHONPATH: ${{ github.workspace }}
    steps:
      - uses: actions/checkout@v4
        with: {repository: 'proplayer1131/sachyhocpdf_downloader-main', token: ${{ secrets.ACTION_TOKEN }}}
      - uses: actions/setup-python@v5
        with: {python-version: "3.10"}
      - id: select_account
        env: {ACCOUNTS_SECRET: ${{ secrets.BHLNK_ACCOUNTS }}, RUN_NUMBER: ${{ github.run_number }}}
        run: |
          ACCOUNTS_LIST=$(echo "${ACCOUNTS_SECRET}" | sed '/^\s*$/d')
          LINE_NUM=$(( ((RUN_NUMBER - 1) % $(echo "${ACCOUNTS_LIST}" | wc -l)) + 1 ))
          ACCOUNT_LINE=$(echo "${ACCOUNTS_LIST}" | awk "NR==${LINE_NUM}")
          echo "BHLNK_EMAIL=$(echo "$ACCOUNT_LINE" | cut -d: -f1)" >> $GITHUB_ENV
          echo "BHLNK_PASSWORD=$(echo "$ACCOUNT_LINE" | cut -d: -f2-)" >> $GITHUB_ENV
      - run: |
          sudo apt-get update && sudo apt-get install -y git jq exiftool libgl1 libopenjp2-7 libffi-dev libssl-dev
          pip install -U pip requests Pillow psutil
          if [ "${PERFORM_OCR}" == "yes" ]; then pip install paddlepaddle paddleocr pymupdf; fi
          if [ -f requirements.txt ]; then grep -v -E 'tkinter|pywin32|win32mica|upx|customtkinter|futures|tqdm' requirements.txt > requirements_linux.txt && pip install -r requirements_linux.txt; fi
      - env: {RCLONE_CONF_CONTENTS: ${{ secrets.RCLONE_CONF }}}
        run: |
          curl -fsSL https://rclone.org/install.sh | sudo bash
          mkdir -p ~/.config/rclone && printf "%s" "$RCLONE_CONF_CONTENTS" > ~/.config/rclone/rclone.conf
          echo "RCLONE_DEST_PATH=1drive:/LSC_Books" >> $GITHUB_ENV
      - id: download_script
        run: python -u scripts/download_one.py
      - id: status_reader
        if: always()
        run: if [ -f "download_status.txt" ]; then echo "DOWNLOAD_STATUS=$(cat download_status.txt)" >> $GITHUB_OUTPUT; else echo "DOWNLOAD_STATUS=SCRIPT_ERROR" >> $GITHUB_OUTPUT; fi
      - id: sanitize
        if: hashFiles('folder_name.txt') != ''
        run: |
          ORIGINAL_NAME=$(cat folder_name.txt)
          SANITIZED_NAME=$(echo "$ORIGINAL_NAME" | sed 's#[*:<>?\/\\|]#_#g')
          [ "$ORIGINAL_NAME" != "$SANITIZED_NAME" ] && mv -- "$ORIGINAL_NAME" "$SANITIZED_NAME"
          echo "sanitized_name=$SANITIZED_NAME" >> $GITHUB_OUTPUT
      - id: metadata_pass_1
        if: steps.status_reader.outputs.DOWNLOAD_STATUS != 'EXISTS' && steps.status_reader.outputs.DOWNLOAD_STATUS != 'SCRIPT_ERROR' && steps.status_reader.outputs.DOWNLOAD_STATUS != 'NOT_FOUND' && steps.sanitize.outputs.sanitized_name != ''
        run: |
          cd "${{ steps.sanitize.outputs.sanitized_name }}"
          find . -name "*.pdf" -print0 | while IFS= read -r -d '' pdf_file; do exiftool -Title="LSC" -Author="LSC" -Subject="LSC" -Creator="LSC" -Producer="LSC" -overwrite_original "$pdf_file"; done
          cd ..
      - id: upload_no_ocr
        if: steps.metadata_pass_1.conclusion == 'success'
        env: {RCLONE_DEST_PATH: "1drive:/LSC_Books/No_OCR"}
        run: |
          TARGET="${{ env.RCLONE_DEST_PATH }}/${{ steps.sanitize.outputs.sanitized_name }}"
          rclone copy "${{ steps.sanitize.outputs.sanitized_name }}" "$TARGET" --transfers=8 --checkers=16 --progress
          echo "RCLONE_LINK_NO_OCR=$(rclone link "$TARGET")" >> $GITHUB_ENV
      - if: env.PERFORM_OCR == 'yes'
        run: |
          cat <<EOF > paddle_ocr_process.py
          import os, fitz, sys, logging, warnings
          from paddleocr import PaddleOCR
          warnings.filterwarnings("ignore"); logging.getLogger("ppocr").setLevel(logging.ERROR); os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
          try: ocr = PaddleOCR(use_textline_orientation=True, lang='vi', use_gpu=False, show_log=False)
          except TypeError:
            try: ocr = PaddleOCR(use_angle_cls=True, lang='vi', use_gpu=False, show_log=False)
            except TypeError: ocr = PaddleOCR(use_angle_cls=True, lang='vi', use_gpu=False)
          def process_folder(folder_path):
            for root, dirs, files in os.walk(folder_path):
              for file in files:
                if file.lower().endswith(".pdf"):
                  try: ocr_pdf(os.path.join(root, file)); print(f"Done: {file}")
                  except Exception as e: print(f"Err {file}: {e}")
          def ocr_pdf(input_path):
            doc = fitz.open(input_path); temp_output = input_path + ".temp.pdf"; has_changes = False
            for page_num, page in enumerate(doc):
              if (page_num + 1) % 5 == 0: print(f"Page {page_num + 1}/{len(doc)}")
              try: result = ocr.ocr(page.get_pixmap(matrix=fitz.Matrix(2, 2)).tobytes("png"), cls=True)
              except: continue
              if not result or result[0] is None: continue
              has_changes = True
              for line in result[0]:
                if line[1][1] < 0.5: continue
                box = line[0]; x0 = min(p[0] for p in box)/2; y0 = min(p[1] for p in box)/2; y1 = max(p[1] for p in box)/2
                try: page.insert_text(fitz.Point(x0, y1-(y1-y0)*0.12), line[1][0], fontsize=(y1-y0)*0.75, fontname="helv", render_mode=3)
                except: pass
            if has_changes: doc.save(temp_output); doc.close(); os.replace(temp_output, input_path)
            else: doc.close(); (os.remove(temp_output) if os.path.exists(temp_output) else None)
          if __name__ == "__main__": (process_folder(sys.argv[1]) if len(sys.argv) > 1 else None)
          EOF
      - id: ocr
        if: steps.status_reader.outputs.DOWNLOAD_STATUS != 'EXISTS' && steps.status_reader.outputs.DOWNLOAD_STATUS != 'SCRIPT_ERROR' && steps.status_reader.outputs.DOWNLOAD_STATUS != 'NOT_FOUND' && steps.sanitize.outputs.sanitized_name != '' && env.PERFORM_OCR == 'yes'
        run: python paddle_ocr_process.py "${{ steps.sanitize.outputs.sanitized_name }}"
      - id: metadata_pass_2
        if: steps.ocr.conclusion == 'success' && env.PERFORM_OCR == 'yes'
        run: |
          cd "${{ steps.sanitize.outputs.sanitized_name }}"
          find . -name "*.pdf" -print0 | while IFS= read -r -d '' pdf_file; do exiftool -Title="LSC" -Author="LSC" -Subject="LSC" -Creator="LSC" -Producer="LSC" -overwrite_original "$pdf_file"; done
          cd ..
      - id: upload_ocr
        if: steps.metadata_pass_2.conclusion == 'success' && env.PERFORM_OCR == 'yes'
        env: {RCLONE_DEST_PATH: "1drive:/LSC_Books"}
        run: |
          TARGET="${{ env.RCLONE_DEST_PATH }}/${{ steps.sanitize.outputs.sanitized_name }}"
          rclone copy "${{ steps.sanitize.outputs.sanitized_name }}" "$TARGET" --transfers=8 --checkers=16 --progress
          echo "RCLONE_LINK_OCR=$(rclone link "$TARGET")" >> $GITHUB_ENV
      - if: always() && hashFiles('telegram_message.txt') != ''
        run: |
          if [ -n "${{ env.RCLONE_LINK_NO_OCR }}" ]; then sed -i "s|\[Äang xá»­ lÃ½...\]|\[Nháº¥n vÃ o Ä‘Ã¢y\](${{ env.RCLONE_LINK_NO_OCR }})|g" telegram_message.txt; sed -i "s|ðŸ”— Link Táº£i:|ðŸ”— Link (No-OCR):|g" telegram_message.txt; else sed -i "s|\[Äang xá»­ lÃ½...\]|\[Upload tháº¥t báº¡i\]|g" telegram_message.txt; fi
          if [ "${{ env.PERFORM_OCR }}" == "yes" ]; then echo "ðŸ”— Link (OCR): $([ -n "${{ env.RCLONE_LINK_OCR }}" ] && echo "[Nháº¥n vÃ o Ä‘Ã¢y](${{ env.RCLONE_LINK_OCR }})" || echo "[Upload tháº¥t báº¡i]")" >> telegram_message.txt; fi
      - if: always() && hashFiles('telegram_message.txt') != ''
        uses: actions/upload-artifact@v4
        with: {name: result-message-${{ github.run_id }}, path: telegram_message.txt, retention-days: 1}
