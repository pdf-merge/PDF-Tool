name: OCR & Merge PDF (from Source)

on:
  workflow_dispatch:
    inputs:
      folder_prefix:
        description: 'Folder prefix (e.g., 107)'
        required: true
        type: string

jobs:
  merge-pdfs:
    runs-on: ubuntu-latest
    env:
      RCLONE_DEST_PATH: "1drive:LSC_Merged"
    steps:
      - name: 1. Install Dependencies & OCRmyPDF from Source
        run: |
          sudo apt-get update
          sudo apt-get install -y git
          
          git clone https://github.com/ocrmypdf/OCRmyPDF.git
          
          echo "Installing dependencies (rclone, pdftk, exiftool, parallel, ocrmypdf)..."
          sudo apt-get install -y \
            rclone pdftk-java exiftool parallel \
            python3-pip python3-dev \
            ghostscript qpdf \
            tesseract-ocr tesseract-ocr-vie tesseract-ocr-eng \
            libopenjp2-7 libffi-dev libssl-dev
            
          cd OCRmyPDF
          echo "Installing OCRmyPDF from source code..."
          pip install .
          echo "OCRmyPDF successfully installed from source."

      - name: 2. Configure Rclone
        run: |
          mkdir -p ~/.config/rclone
          echo "${{ secrets.RCLONE_CONF_BASE64 }}" | base64 -d > ~/.config/rclone/rclone.conf

      - name: 3. Find and Download
        env:
          FOLDER_PREFIX: ${{ inputs.folder_prefix }}
        run: |
          mkdir -p downloads
          echo "Searching for directory with prefix: $FOLDER_PREFIX"
          TARGET_DIR_NAME=$(rclone lsf "1drive:LSC_Books" --dirs-only | grep "^${FOLDER_PREFIX}_" | head -n 1 | sed 's/\/$//')
          
          if [ -z "$TARGET_DIR_NAME" ]; then
            echo "::error::No directory found starting with '${FOLDER_PREFIX}_' in 1drive:LSC_Books."
            exit 1
          fi
          
          echo "Found target directory: $TARGET_DIR_NAME"
          RCLONE_REMOTE_PATH="1drive:LSC_Books/$TARGET_DIR_NAME"
          
          echo "Starting download from $RCLONE_REMOTE_PATH..."
          rclone copy "$RCLONE_REMOTE_PATH" ./downloads/ --include "*.pdf"
          
          if [ -z "$(ls -A downloads/*.pdf 2>/dev/null)" ]; then
            echo "::error::No PDF files found in $TARGET_DIR_NAME."
            exit 1
          fi
          
          echo "Download complete."
          CLEAN_DIR_NAME=$(echo "$TARGET_DIR_NAME" | tr ' ' '_')
          FINAL_FILE_NAME="${CLEAN_DIR_NAME}.pdf"
          
          echo "FINAL_FILE_NAME=$FINAL_FILE_NAME" >> $GITHUB_ENV
          echo "TARGET_DIR_NAME=$TARGET_DIR_NAME" >> $GITHUB_ENV

      - name: 4. Run OCRmyPDF on each file (Skip if already OCR'd)
        run: |
          cd downloads
          echo "Starting OCR for all downloaded PDF files (skipping if text exists)..."
          
          mapfile -t pdf_files < <(ls -v *.pdf)

          for f in "${pdf_files[@]}"; do
            echo "Processing: $f"
            TEMP_OCR_FILE="ocr_${f}"
            
            # ÄÃ£ xÃ³a --force-ocr
            # OCRmyPDF sáº½ tá»± Ä‘á»™ng dÃ¹ng nhiá»u lÃµi (CPU)
            ocrmypdf \
              --language "vie+eng" \
              "$f" \
              "$TEMP_OCR_FILE"
            
            # Láº¥y mÃ£ thoÃ¡t (exit code)
            EXIT_CODE=$?
            
            if [ $EXIT_CODE -eq 0 ]; then
              # 0 = ThÃ nh cÃ´ng, file Ä‘Ã£ Ä‘Æ°á»£c OCR
              mv "$TEMP_OCR_FILE" "$f"
              echo "âœ… OCR complete for: $f"
            elif [ $EXIT_CODE -eq 6 ]; then
              # 6 = ÄÃ£ cÃ³ text, ocrmypdf khÃ´ng lÃ m gÃ¬ cáº£
              echo "â­ï¸ Skipping OCR for: $f (already has text)"
              # KhÃ´ng cáº§n lÃ m gÃ¬, file gá»‘c $f Ä‘Æ°á»£c giá»¯ nguyÃªn
              rm -f "$TEMP_OCR_FILE" # XÃ³a file temp rá»—ng náº¿u cÃ³
            else
              # Báº¥t ká»³ mÃ£ nÃ o khÃ¡c lÃ  lá»—i
              echo "::error::OCRmyPDF failed for file: $f (Exit code: $EXIT_CODE)"
              exit 1 # ThoÃ¡t ngay náº¿u cÃ³ lá»—i
            fi
            
          done

          echo "All files have been processed."

      - name: 5. Merge and Create Nested Bookmarks (pdftk)
        run: |
          cd downloads
          BOOKMARK_FILE="bookmarks.txt"
          MERGED_TEMP_FILE="merged_temp.pdf"
          FINAL_FILE="${{ env.FINAL_FILE_NAME }}"
          rm -f "$BOOKMARK_FILE" "$MERGED_TEMP_FILE" "$FINAL_FILE"
          
          PAGE_COUNT=1
          
          mapfile -t pdf_files < <(ls -v *.pdf)
          
          for f in "${pdf_files[@]}"; do
              if [ "$f" == "$MERGED_TEMP_FILE" ] || [ "$f" == "$FINAL_FILE" ]; then
                  continue
              fi
              
              # --- MODIFIED: This section now nests original bookmarks ---
              TITLE_TEMP=$(echo "$f" | sed 's/\.pdf$//')
              TITLE=$(echo "$TITLE_TEMP" | sed 's/^[0-9]*_//')
              
              echo "Creating Level 1 bookmark for: $TITLE (Page $PAGE_COUNT)"
              echo "BookmarkBegin" >> "$BOOKMARK_FILE"
              echo "BookmarkTitle: $TITLE" >> "$BOOKMARK_FILE"
              echo "BookmarkLevel: 1" >> "$BOOKMARK_FILE"
              echo "BookmarkPageNumber: $PAGE_COUNT" >> "$BOOKMARK_FILE"
              
              # Dump existing bookmarks, increment their level, and adjust page numbers
              echo "Dumping and nesting original bookmarks from $f..."
              OFFSET=$((PAGE_COUNT - 1))
              pdftk "$f" dump_data | \
                grep -E "^(BookmarkBegin|BookmarkTitle|BookmarkLevel|BookmarkPageNumber)" | \
                awk -v offset="$OFFSET" '
                  {
                    if ($1 == "BookmarkLevel:") {
                      print "BookmarkLevel: " ($2 + 1)
                    } else if ($1 == "BookmarkPageNumber:") {
                      print "BookmarkPageNumber: " ($2 + offset)
                    } else {
                      print
                    }
                  }
                ' >> "$BOOKMARK_FILE"
              # --- END OF MODIFICATION ---
              
              CURRENT_PAGES=$(pdftk "$f" dump_data | grep NumberOfPages | awk '{print $2}')
              PAGE_COUNT=$((PAGE_COUNT + CURRENT_PAGES))
          done
          
          echo "Merging all PDF files..."
          pdftk "${pdf_files[@]}" cat output "$MERGED_TEMP_FILE"
          
          echo "Applying new nested bookmarks..."
          pdftk "$MERGED_TEMP_FILE" update_info "$BOOKMARK_FILE" output "$FINAL_FILE"
          
          rm "$MERGED_TEMP_FILE" "$BOOKMARK_FILE"
          echo "Merge and bookmark complete. Final file: $FINAL_FILE"

      - name: 6. Force PDF Metadata (exiftool)
        run: |
          cd downloads
          FINAL_FILE="${{ env.FINAL_FILE_NAME }}"
          exiftool -Title="LSC" \
                   -Author="LSC" \
                   -Subject="LSC" \
                   -Creator="LSC" \
                   -Producer="LSC" \
                   -overwrite_original \
                   "$FINAL_FILE"
          
          export TZ="Asia/Ho_Chi_Minh"
          exiftool -AllDates="now" \
                   -overwrite_original \
                   "$FINAL_FILE"
          echo "Metadata update complete."

      - name: 7. Upload to OneDrive
        run: |
          FINAL_FILE_PATH="downloads/${{ env.FINAL_FILE_NAME }}"
          echo "Uploading $FINAL_FILE_PATH to ${{ env.RCLONE_DEST_PATH }}..."
          rclone copy "$FINAL_FILE_PATH" "${{ env.RCLONE_DEST_PATH }}"
          echo "Upload complete."

      - name: 8. Create Artifact for Bot
        run: |
          cd downloads
          FINAL_FILE="${{ env.FINAL_FILE_NAME }}"
          NEW_LINK=$(rclone link "${{ env.RCLONE_DEST_PATH }}/$FINAL_FILE")
          
          BOOK_NAME_RAW=$(echo "${{ env.TARGET_DIR_NAME }}" | sed "s/^${{ inputs.folder_prefix }}_//")
          BOOK_NAME=$(echo "$BOOK_NAME_RAW" | tr '_' ' ')
          
          echo "âœ… *OCR & Gá»™p SÃ¡ch ThÃ nh CÃ´ng* " > artifact.txt
          echo "ðŸ†” *SÃ¡ch:* \`$BOOK_NAME\`" >> artifact.txt
          echo "ðŸ”— *Link Táº£i Má»›i:* [Nháº¥n vÃ o Ä‘Ã¢y]($NEW_LINK)" >> artifact.txt

      - name: 9. Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: bot-message
          path: downloads/artifact.txt
